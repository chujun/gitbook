
mysql优化器机制

齐头并进，举案齐眉
* 查询优化
* 索引优化
* 库表结构优化

# 6.1为什么查询速度会慢
查询最重要的是响应时间.查询任务可以由一系列子任务组成，每一个子任务都会消耗一定时间.
优化查询，实际上要优化其子任务(又回到了第三章的方法论了)
* 要么消除其中一些子任务
* 要么减少子任务的执行次数
* 要么让子任务运行得更快

从MySQL体系架构图中可以看出查询的生命周期大致如下：
从客户端到服务器,然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。
"执行"算是真个生命周期最重要的阶段，其中包括大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序,分组等。

查询可能花费时间地方(很多通用性能优化时间花费)
* 网络
* CPU计算
* 生成统计信息和执行计划
* 锁等待(互斥等待)
* I/O操作
* 上下文切换
* 系统调用等等


# 6.2慢查询基础:优化数据访问
查询性能低下最基本的原因是访问数据太多

分析方法确认是否访问了不必要的数据
* 1.确认应用程序是否在检索大量超过需要的数据.这通常意味着访问了太多的行,但有时候也可能是访问了太多的列(然而在现有orm框架下基本列全访问,开发便捷角度出发).
* 2.确认MySQL服务器层是否在分析大量超过需要的数据行(分析+量化)

## 6.2.1是否想数据库请求了不需要的数据
最终这些多余数据又被丢弃了

坏处:
* 增加mysql服务器负担
* 增加网络开销
* 消耗应用服务器的CPU和内存资源

### 典型案例场景
1.查询不需要的记录

2.多表关联时返回全部列
```mysql
select * from actor 
    inner join film_actor using(actor_id)
    INNER JOIN film using(film_id)
    where film.title='Academy Dinosaur';
```
返回了全部数据列,正确应该是只取需要的列 select actor.* from ...

3.总是取出全部列
典型的业务开发代码:"select *"
select 所有列名 简化*解析，如果这么用需要明确知道代价和好处
好处:提高研发效率，加上缓存机制
坏处:有一定的性能影响

4.重复查询相同的数据
同一个业务请求中处理总是查询相同的数据

## 6.2.2Mysql是否在扫描额外的记录
首先对于mysql,最简单的衡量查询开销的三个指标如下:
* 响应时间
* 扫描行数
* 返回行数

这三个指标都会记录到mysql的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。

### 响应时间
最重要的指标，两部分时间之和：服务时间和排队时间(等待时间)(计算机所有响应时间都可以分为该两部分)
服务时间：数据库处理这个查询真正花了多长时间.
排队时间：服务器因为等待某系资源(CPU/锁/IO等等)而没有真正执行查询的时间-可能是等I/O操作完成，也可能是等待行锁，等等。
不幸的是很难测量各个部分等待时间

需要注意的是响应时间可能是一个问题的结果也可能是一个问题的原因，需要用到第三章的
"单个查询问题还是服务器问题"一节介绍的技术来确定到底是因还是果。

#### 响应时间"快速上限估计"方法:
了解这个查询需要哪些索引以及它的执行计划是什么，
然后计算大概需要多少个顺序和随机I/O，
再用其乘以再具体硬件条件下一次I/O的消耗时间.
最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值.

预估方法来源于参考资料书籍1

### 扫描的行数和返回行数

一般扫描行数对返回行数比率通常较小，一般在1:1和10:1之间

### 扫描的行数和访问类型 
在评估查询开销时候，需要考虑下从表中找到某一行数据的成本.
explain语句中的type列反应了访问类型(详见官方文档，里面有详细介绍)
常数引用,唯一索引查询，范围扫描,索引扫描，全表扫描
快---------------------------------->慢

如果查询没有办法找到合适的访问类型，那么解决的最好办法通常是增加一个合适的索引,

#### 案例
使用索引和不使用explain的type类型和预计扫描行数大不相同
![6explain有无索引type不同](img/six/6explain有无索引type类型大不相同.png)

一般mysql使用where条件的三种方式，从好到坏依次为:
* 在索引中使用where条件来过滤掉不匹配的记录，这是在存储引擎层完成的。不需要mysql服务器介入
* 使用索引覆盖扫描(在Extra列中出现了Using index)来返回记录,直接从索引中过滤不需要的记录
并返回命中的结果。这是在mysql服务器层完成的，但无须再回表查询记录(这个操作怎么理解呢)
* 从数据表中返回数据，然后过滤不满足条件的记录(Extra列中出现Using where).这在mysql服务器
层完成，mysql需要先从数据表读出记录然后过滤。


如果发现查询需要扫描大量的数据但只返回少数的行(可能场景之一汇总聚合查询),那么通常可以尝试下面的技巧去优化它:
* 使用索引覆盖扫描，把所有需要用的列都放到索引中,这样存储引擎无需回表获取数据行就可以返回结果
* 改变库表结构。例如使用单独的汇总表（第4章提到过)
* 重写这个复杂的查询，让mysql优化器能够以更优化的方式执行这个查询(本章后续讨论的问题)

# 6.3重构查询的方式
TODO:cj to be done

# 参考资料
## 书籍
* 1.Lahdenmaki和Mike Leach编写的Relational Database Index Design and Optimizers(Wiley出版社)


