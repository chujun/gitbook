
#5.1 索引基础
在mysql中，存储引擎使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行

##5.1.1索引类型
在mysql中,索引是在存储引擎层而不是服务器层实现的,所以没有统一的索引标准，不同存储引擎的索引类型也不一样

索引类型
###B-Tree索引
B-Tree数数据结构自行维基百科(通常意味着所有值都是顺序存储的，并且每一个叶子页到根的距离相同)

innodb用的就是B+Tree索引，后面还会详细介绍

*B-Tree结构大致逻辑结构*
![B-Tree结构上索引](img/five/B-Tree结构上索引图重要.png)

观察可知道和索引值相等的节点也在叶子页中

***[图重要系列]理解了这张图,B-Tree索引的逻辑结构，才能理解Mysql的最左匹配原则,多列匹配，范围匹配限制等索引规则,
其实都能根据这张图推理可知***

大致搜索算法步骤
1. 从索引根节点(上图未画出)开始进行搜索,
2. 根节点槽中存放了只想子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值(可能是多个列组成的值)和要查找的值
可以找到合适的指针进入下层子节点，这些指针实际上定义了当前节点的子节点页中值的上限和下限。
3. 最终存储引擎要么是找到对应的值，要么该记录不存在。

B-Tree对索引列是顺序组织存储的，所以适合查找范围数据

*下面是B-Tree结构之多列值索引,key(last_name,first_name,dob)[图重要系列]*
![B-Tree结构之多列值索引图重要](img/five/B-Tree结构之多列值索引图重要.png)

####B-Tree索引适合的查询类型(其实能根据上面B-Tree结构图推理可知)
```mysql
create table people(
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum('m','f') not null,
    key(last_name,first_name,dob)
);
```
* 全值匹配:和索引中的所有列进行匹配，例如查找姓名为Cuba Allen,出生于1960-01-01的人
* 匹配最左前缀:查找所有姓为Allen的人，即只使用索引的第一列
* 匹配列前缀:可以只匹配某一列的值的开头部分.例如查找所有以J开头的姓的人,只使用了索引的第一列
* 匹配范围值:例如查找姓在Allen和Barrymore之间的人.这里只使用了索引的第一列
* 精确匹配某一列并范围匹配另外一列:例如查找所有姓为Allen,并且名字是字母K开头的人。即第一列last_name全匹配，第二列first_name范围匹配
* 只访问索引的查询:即只需要访问索引，而无需访问数据行.后面单独谈论这种"覆盖索引"的优化

* 用于查询中的ORDER BY操作(按顺序查找):如果order by子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求

####B-Tree索引的限制(其实也能根据上面B-Tree结构图推理可知)
* 如果不是按照索引的最左列开始查找，则无法使用索引.例如查找名字(first_name)为Bill的人，也无法查找某个特定生日(dob)的人,
也无法查找姓(last_name)以某个字母结尾的人
* 不能跳过索引中的列.例如无法查询姓(last_name)为Smith并且在某个特定日期出生的人.索引部分使用,mysql只能使用索引的第一列
* 如果查询中有某个列的查询范围,则其右边所有列都无法索引查询.例如查询where last_name='Smith' and
first_name like 'J%' and dob='1976-12-23'，这个查询只能使用索引的前两列,因为like是一个范围条件

*索引的顺序是相当重要*

###哈希索引
基于哈希表实现,只有精确匹配索引所有列的查询才有效。
每一行数据，存储引擎都会针对索引所有列计算一个哈希码(hash code)。
哈希碰撞

缺点
* 哈希索引只包含哈希值和数据行指针，不存储字段值。所以必须读取行
* 哈希索引数据并不是顺序存储的，所以无法拥有排序
* 不支持部分索引列匹配查找。因为哈希索引是用索引所有列内容计算哈希值。例如(A,B)建立哈希索引，如果只查询数据列A，则无法使用该索引.
* 哈希索引只支持等值比较查询，包括=,in.不支持任何范围查询
* 访问哈希索引数据非常快，除非有很多哈希冲突
* 如果哈希冲突非常严重的话，索引维护操作也可能非常高。

特定使用场合
数据仓库应用中有一种经典的"星型"schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。

Innodb引擎有一种特别的功能叫"自适应哈希索引"(adaptive hash index),当Innodb注意到某些索引值被使用得非常频繁时，
它会在内存中基于B-Tree索引之上再创建一个哈希索引。(用户无法控制)
(这个不就是类似于应用系统中加上本地缓存HashMap嘛，一个道理，只不过取了个高大上的名字自适应哈希索引)

####创建自定义哈希索引
思路：在B-Tree索引基础上创建一个伪哈希索引。使用哈希值而不是索引值作为B-Tree进行索引列查找。需要在where子句中
手动使用哈希函数.

案例:字段存储url，并需要查询
```mysql
select * from website where url="https://www.mysql.com";
```
可以删除原来url列的索引，而新增一个索引列url_crc，使用crc32做哈希
```mysql
select * from website where url="https://www.mysql.com" and url_crc=CRC32("https://www.mysql.com");
```
这样会效率极高

缺陷:需要维护哈希值，可以手动维护，也可以使用触发器实现


###空间数据索引(R-Tree)
mysql对GIS支持并不完善,对GIS支持较完善的是PostgreSQL的PostGIS

###全文索引
搜索引擎

###其他索引类别
分形树索引(TukuDB,较新的一个数据结构,既有B-Tree的很多优点，也避免了B-Tree的一些缺点)


#5.2索引的优点

三大优点
* 1.索引大大减少了服务器需要扫描的数据量。
* 2.索引可以帮助服务器避免排序和临时表。
* 3.索引可以将随机I/O变为顺序I/O。

#####"三星索引"
* 1.将相关记录放到一起则获得"一星"
* 2.如果索引中的数据顺序和查找的排列顺序一致则获得"二星"
* 3.如果索引中的列包含了查询中需要的全部列则获得"三星"

##索引的适用范围
* 非常小表,不必要适用索引，大部分情况下简单的全表扫描更高效
* 中到大型的表，索引非常有效
* 特大型表，建立和使用索引的代价将随之增长。
需要一种技术可以直接区分出查询需要的一组数据,而不是一条记录一条记录地匹配，例如可以使用分区技术[参考第7章]
表的数量特别多，也可以考虑建议一个元数据信息表。例如执行哪些需要聚合多个应用分布在多个表的数据的查询，则需要记录
"哪个用户的信息存储在哪个表中"的元数据,这样在查询时就可以直接忽略哪些不包含指定用户信息的表.

#5.3高性能的索引策略
##5.3.1独立的列
"独立的列"指的是索引列不能是表达式的一部分，也不能是函数的参数
(自序:好像也不绝对，例如前面的crc32(url)函数,以及JPA中的)
`" AND (o.status in (:statuses) OR COALESCE(:statuses,NULL) IS NULL)" +`

下面查询无法使用actor_id列的索引:
```mysql
select actor_id from sakila.actor where actor_id+1=5;
```
```mysql
select * from mytable where TO_DAYS(CURRENT_DATE)-TO_DAYS(date_col)<=10;
```
```mysql
## c_user_id索引,id主键索引
#走索引
select * from t_user_1q where c_user_id ="100000";
##没走索引
select * from t_user_1q where c_user_id ="100000"+"1";
#走索引
select * from t_user_1q where id =100000;
##走了索引
select * from t_user_1q where id =100000+1;

```

最佳实践
*简化where条件的习惯，始终将索引列单独放在比较符号的一侧.*

##5.3.2 前缀索引和索引选择性
场景有时候需要索引很长的字符列,这会让索引变得大而慢.可以考虑索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。

缺点：
* 降低索引选择性(是指不重复的索引值(也成基数,cardinality)和数据表的记录总数(#T)的比值，范围从1/#T到1之间)
* mysql无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描

索引选择性越高查询效率越高，可以在查询时过滤掉更多的行。
唯一索引选择性是1，这是最好的索引选择性，查询性能也是最好的(当然也是有成本的,构建成本相应也高了)

对于BLOB，TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为mysql不允许索引这些列的完整长度.

####前缀索引的应用技巧
* 选择足够长的前缀以保证较高的选择性--->使得前缀索引的选择性接近于索引整个列(即，前缀的"基数"应该接近于完整列的"基数")
* 同时又不能太长(以便节约空间)

####案例:如何具体计算一个前缀索引的长度呢
#####方法一(看看就好)
![A方案一计算一个前缀索引的长度1](img/five/A方案一计算一个前缀索引的长度1.png)
![A方案一计算一个前缀索引的长度2](img/five/A方案一计算一个前缀索引的长度2.png)

#####方法二:计算完整列的选择性，并使前缀的选择性接近于完整列的选择性,另外需要关注下你希望前缀索引长度下的数据分布情况
```
select count(DISTINCT  city)/COUNT(*) as a from sakila.city_demo;
+--------------+
| a            |
+--------------+
|        0.0312|
+--------------+
```
可以在一个查询中针对不同前缀长度进行计算，这对于大表非常有用.
```
select count(DISTINCT LEFT(city,3))/COUNT(*) AS sel3,
    count(DISTINCT LEFT(city,4))/COUNT(*) AS sel4,
    count(DISTINCT LEFT(city,5))/COUNT(*) AS sel5,
    count(DISTINCT LEFT(city,6))/COUNT(*) AS sel6,
    count(DISTINCT LEFT(city,7))/COUNT(*) AS sel7,
from sakila.city_demo;
+--------+--------+--------+--------+--------+
|sel3    |sel4    |sel5    |sel6    |sel7    |
+--------+--------+--------+--------+--------+
|  0.0239|  0.0293|  0.0305|  0.0309|  0.0310|
+--------+--------+--------+--------+--------+
```
查询限时当前缀长度到达7的时候，再增加前缀长度，选择性提升的幅度已经很小了。

注意：只看平均选择性还是不够的，也有例外的情况，需要考虑最欢情况下的选择性。
平均选择性让你认为前缀长度为4或者5的索引已经足够了，但如果数据分布很不均匀，可能就会有陷阱.

例如观察前缀为4的最长出现城市的次数，可以看到数据分布明显不均匀
```
select count(*) as cnt,LEFT(city,4)as pref
from sakila.city_demo GROUP BY perf order by cnt desc limit 5;

+--------------+--------------+
|cnt           |pref          |
+--------------+--------------+
|           205|San           |
|           200|Sant          |
|           135|Sout          |
|           104|Chan          |
|            91|Toul          |
+--------------+--------------+
```
*真实数据，真实城市名上可能很多城市都以"San","New"词开头*

##5.3.3多列索引
新手玩家索引方式，为每个可能的where列创建单独的索引
```mysql
##demo
create table t(
  c1 int,
  c2 int,
  c3 int,
  key(c1),
  key(c2),
  key(c3)  
);
```
这样一来最好的情况下也只能是一星索引，其性能比起真正最优的索引可能差几个数量级。

案例
表film_actor在字段film_id和actor_id上各有一个单列索引，
但对于下面这个查询where条件，这两个单列索引都不是好的选择
```mysql
select film_id,actor_id from sakila.film_actor 
where actor_id=1 or film_id=1;
```
在老mysql版本中(书中最新也才5.1版本，估计现在不会这么傻了)，mysql对这个查询会使用全表扫描。
除非改写成如下的两个查询UNION方式
```mysql
select film_id,actor_id from sakila.film_actor
where actor_id=1
UNION ALL 
select film_id,actor_id from sakila.film_actor

where film_id=1 and actor_id<>1;
## 感觉actor_id<>=1没必要要啊
```
但在mysql5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果合并。

这种算法有三个变种
* OR条件的联合
* AND条件的相交
* 组合前两种情况的联合及相交
![where中or条件执行计划](img/five/5where中or条件执行计划.png)

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕
* 当服务器对多个索引做相交操作时（通常有多个AND条件），通常说明需要一个包含所有相关列的多级索引，
而不是多个单独的单列索引
* 当服务器需要对多个索引做联合操作时(通常有多个OR条件),通常需要耗费大量CPU和内存资源在算fan的
缓存、排序和合并操作上。特别是有些索引选择性不高，需要合并扫描返回大量数据的时候。
* 优化器不会把这些计算到"查询成本"(cost)中去，优化器只关心随机页面读取。导致查询成本被低估，导致该执行计划还不如直接走全表扫描。

可以通过参数*optimizer_switch*来关闭索引合并功能，也可以使用ignore index提示让优化器忽略掉某些索引.


###5.3.4选择合适的索引列顺序
针对索引类型范围
针对B-Tree索引，哈希或者其他类型索引并不会像B-Tree索引一样按顺序存储数据
三星索引的一个重要标志：多列索引的顺序

####question如何选择索引的列顺序呢？
一个经验法则:将选择性最高的列放到索引最前列。（没有放之四海皆准的法则）
有些场景可能有帮助，但通常不如避免随机IO和排序那么重要(TODO:cj这个怎么理解呢)
* 当不考虑排序和分组是，将选择性最高的列放在前面通常是好的.但是性能不仅仅依赖于所有列的选择性(整体基数),
也和查询条件的具体值有关(值的分布).也可能需要根据哪些运行频率最高的查询来调整索引列的顺序

案例选择哪一个列作为多列索引列的第一列呢？
```mysql
select * from payment where staff_id=2 and customer_id=584;
```

如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询:
```
mysql> select count(DISTINCT  staff_id)/count(*) as staff_id_selectivity,
count(distinct customer_id)/count(*) as customer_id_selectivity,
count(*) from payment\G;
******************1.row*************
staff_id_selectivity:0.0001
customer_id_selectivity:0.0373
count(*):16049
```
customer_id选择性更高，所以将其作为索引列的第一列

案例二：值分布不均
在某些应用中，对没有登录的用户，都将其用户名记录为"guest",这样guest就成为了一个特殊用户ID。
查询其他账号ID正常，但查询这个账号可能就会出现服务器性能问题了。

案例三:值分布不均的问题
管理员组用户数据过多
![管理员组数据过多](img/five/5值分布不均-管理员组数据过多.png)

###5.3.5聚簇索引
概念上:聚簇索引并不是一种单独的索引类型，而是一种*数据存储方式*。具体细节依赖其实现方式，
*innodb的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行*。

*数据存储结构*
![聚簇索引的数据分布](img/five/5聚簇索引的数据分布.png)

*特征*
* 表数据行存放在索引的叶子页(leaf page)中，节点页还是只包含了索引列。
* "聚簇"表示数据行和相邻兼职紧凑的存储在一起(不过需要注意的是innodb只聚集在同一个页面中的记录,包含相邻键值的页面可能会相距甚远)
* 因为无法同时把数据行存放在两个不同的地方，一个表只能有一个聚簇索引
(覆盖索引可以模拟多个聚簇索引的情况，本章后面介绍，TODO:cj这个怎么理解)
* a1.innodb通过主键聚集数据,""被索引的列"就是主键列。
* a2.如果没有定义主键,innodb会选择一个唯一的非空索引替代
* a3.如果没有没有这样的索引，innodb会隐式定义一个主键来作为聚簇索引
* a总.innodb不论何种情况，一定会有聚簇索引(想想也对，数据行存储在聚簇索引中，不然怎么存储数据行呢)
* 因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。

*优点*
* 可以把相关数据保存在一起,这样只需要从磁盘读取少数数据页就能获取某个用户的全部邮件。
如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O.
* 数据访问更快.聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常
比在非聚簇索引中查找要快(减少了一次回表啊)
* 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

*缺点*
* 1.聚簇索引最大限度的提高了I/O密集型应用的性能，但如果全部数据都放在内存，则访问顺序就没那么重要了，聚簇索引也就没什么优势了
* 2.插入速度严重依赖插入顺序。按照主键顺序插入是加载数据到Innodb表中速度最快的方式。
但如果不是按照主键顺序加载数据，那么加载完成后最好使用*OPTIMIZE TABLE*命令重新组织下表
* 3.更新聚簇索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置。
* 4.基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临"页分裂"问题。当行的主键值要求必须将这一行插入到某个已满的页中时，
存储引擎会将该页分裂成两个页面来容纳该行(那不是两页都不满了)，这就是一次*页分裂*操作。页分裂
会导致表占用更多的磁盘空间
* 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
* 二级索引(非聚簇索引)可能比想象的要更大一些，因为在二级索引的叶子节点包含了引用行的主键列
* 二级索引访问数据行需要两次索引查找(回表),而不是一次.

缺点4页分裂问题告诉我们最佳实践：
* 表一定要有id作为主键(大表，不过也是db常规最佳实践了),不然其他列成为聚簇索引后问题很大。
* 主键id自增，没事别更新主键id值,别跳id插入

为什么需要两次索引查找？
因为二级索引中保存的"行指针"的实质，保存的是行的主键值，而不是指向行的物理位置。

----->找到二级索引的叶子节点对应的行主键值----->根据行主键值去聚簇索引查找对应的数据行

#### innodb和myisam的数据分布对比

数据情况
该表主键取值1~10000，按照随机顺序插入并使用*OPTIMIZE TABLE*命令做了优化。
换句话说，数据在磁盘上的存储方式已经最优,但行的顺序是随机的。
列col2的值是从1~100之间随机赋值，所以有很多重复值

```mysql
create table layout_test(
    col1 int not null,
    col2 int not null,
    PRIMARY KEY(col1),
    key(col2)
);
```
*myisam数据分布情况*(了解下即可)
![myisam索引数据分布1](img/five/5myisam索引数据分布1.png)
![5myisam索引数据分布2](img/five/5myisam索引数据分布2.png)

*innodb数据分布*
*Innodb表的主键分布图*[图重要系列]
![innodb表的聚簇索引分布](img/five/5innodb表的聚簇索引分布图重要.png)

从图中看显示了整个表，而不单单是索引，还有数据行信息
在innodb中，聚簇索引"就是"表
聚簇索引的每一个叶子节点都包含了
* 主键值，
* 事务ID，
* 用于事务和MVCC的回滚指针
* 以及所有的剩余列(在这个例子中是col2)

*innodb表的二级索引分布图*
![](img/five/5innodb表的二级索引分布图重要.png)
二级索引的叶子节点存储的不是"行指针"，而是主键值，并以此作为指向行的"指针"。
这种方式优点：减少了当出现行移动或者数据页分裂时二级索引的维护工作。
缺点：使用主键值当作指针会让二级索引占用更多的空间

*innodb和myisam聚簇和非聚簇表对比图*
![](img/five/5innodb和myisam聚簇和非聚簇表对比图重要.png)


##### 在innodb表中按主键顺序插入行
DB最佳实践:
* 表id作为主键,使用AUTO_INCREMENT自增列，可以保证数据行按顺序写入
* 避免随机(不连续值的分布范围非常大)聚簇索引，例如UUID作为聚簇索引，
它使聚簇索引插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。

顺序主键的缺点???(先思考下后面有)

案例测试
```mysql
## 第一张表使用整数ID插入user_info表
create TABLE user_info(
    id int unsigned not null AUTO_INCREMENT,
    name varchar(64) not null DEFAULT '',
    email varchar(64) not null DEFAULT '',
    password varchar(64)not null DEFAULT '',
    dob date DEFAULT null,
    country_id smallint unsigned not null DEFAULT '0',
    PRIMARY KEY (id),
    UNIQUE KEY email(email),
    KEY country_id(country_id)
)ENGINE=innodb;
```
```
## 第二张表，除了主键改为UUID，其他和第一张表完全一样
create TABLE user_info_uuid(
    uuid varchar(36) not null,
    ...
    PRIMARY KEY (uuid)
    ...
)
```
测试
* 1.向两个表各插入100w条记录
* 2.再分别插入300w记录，使得索引的大小超过服务器的内存空间

|表名|行数|时间秒|索引大小MB|
|---|---|---|---|
|user_info|100w|137|342|
|user_info_uuid|100w|180|544|
|user_info|300w|1233|1036|
|user_info_uuid|300w|4522|1701|

可以观察到UUID主键插入行花费时间更长，索引占用空间也更大
* 一方面由于主键字段更长
* 另一方面由于页分裂和碎片导致的(TODO:cj 怎么从mysql内部数据观察出来呢)

*向聚簇索引插入 顺序索引值*
聚簇索引也是有排序顺序的(这点不要忘记)


![向聚簇索引插入顺序索引值](img/five/5向聚簇索引插入顺序索引值.png)
因为主键值是顺序的,所以innodb把新记录存储在上条记录后面,当达到页最大填充因子时,新纪录会写入新页中。
这样主键页就会近似于被顺序的记录填满(二级索引页可能是不一样的)

页的最大填充因子(innodb默认最大填充因子是页大小的15/16，留出部分空间用于以后修改)
*向聚簇索引插入 无序索引值UUID*
![向聚簇索引中插入无序索引值](img/five/5向聚簇索引中插入无序索引值.png)
因为新行主键值UUID是无序的，所以innodb无法简单的总是把新行插入到索引的最后，而是总需要为新记录寻找到合适的位置
---通常是已有数据的中间位置--这样就有很多额外缺点问题
* 无法利用缓存(内存最近访问原则)写入目标页也可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，
innodb在插入之前不得不先找到并从磁盘读取目标到内存中，这将*导致大量随机I/O*
* 写入是乱序的，innodb不得不*频繁做页分裂操作*，以便为新记录分配空间。同时
页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页(TODO:cj 为啥不是两个????)
* 因为频繁页分裂，页会变得稀疏并被不规则地填充，所以最终会有*数据碎片*

可能需要做一次OPTIMIZE TABLE来重建表并优化页的填充

顺序主键缺点？
高并发工作负载下，innodb按主键顺序插入可能会造成明显争用。
* 主键"上界"会成为热点，因为所有插入都发生在这里，所以并发插入可能导致*间隙锁竞争*
* 另一个热点可能是AUTO_INCREMENT锁机制；

如果遇到第二个问题，可能需要重新考虑设计表或者应用，或者更改innodb_autoinc_lock_mode配置

##5.3.6覆盖索引
TODO:cj to be done


# 资料
##书籍
[索引->Tapio Lahdenmaki和Mike Leach编写的Relational Database Index Design and the Optimizers]
里面详细介绍了如何计算索引的成本和作用，如果评估查询速度，如何分析索引维护的代价和其带来的好处等
