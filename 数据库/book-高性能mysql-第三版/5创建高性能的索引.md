
#5.1 索引基础
在mysql中，存储引擎使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行

##5.1.1索引类型
在mysql中,索引是在存储引擎层而不是服务器层实现的,所以没有统一的索引标准，不同存储引擎的索引类型也不一样

索引类型
###B-Tree索引
B-Tree数数据结构自行维基百科(通常意味着所有值都是顺序存储的，并且每一个叶子页到根的距离相同)

innodb用的就是B+Tree索引，后面还会详细介绍

*B-Tree结构大致逻辑结构*
![B-Tree结构上索引](img/five/B-Tree结构上索引图重要.png)

观察可知道和索引值相等的节点也在叶子页中

***[图重要系列]理解了这张图,B-Tree索引的逻辑结构，才能理解Mysql的最左匹配原则,多列匹配，范围匹配限制等索引规则,
其实都能根据这张图推理可知***

大致搜索算法步骤
1. 从索引根节点(上图未画出)开始进行搜索,
2. 根节点槽中存放了只想子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值(可能是多个列组成的值)和要查找的值
可以找到合适的指针进入下层子节点，这些指针实际上定义了当前节点的子节点页中值的上限和下限。
3. 最终存储引擎要么是找到对应的值，要么该记录不存在。

B-Tree对索引列是顺序组织存储的，所以适合查找范围数据

*下面是B-Tree结构之多列值索引,key(last_name,first_name,dob)[图重要系列]*
![B-Tree结构之多列值索引图重要](img/five/B-Tree结构之多列值索引图重要.png)

####B-Tree索引适合的查询类型(其实能根据上面B-Tree结构图推理可知)
```mysql
create table people(
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum('m','f') not null,
    key(last_name,first_name,dob)
);
```
* 全值匹配:和索引中的所有列进行匹配，例如查找姓名为Cuba Allen,出生于1960-01-01的人
* 匹配最左前缀:查找所有姓为Allen的人，即只使用索引的第一列
* 匹配列前缀:可以只匹配某一列的值的开头部分.例如查找所有以J开头的姓的人,只使用了索引的第一列
* 匹配范围值:例如查找姓在Allen和Barrymore之间的人.这里只使用了索引的第一列
* 精确匹配某一列并范围匹配另外一列:例如查找所有姓为Allen,并且名字是字母K开头的人。即第一列last_name全匹配，第二列first_name范围匹配
* 只访问索引的查询:即只需要访问索引，而无需访问数据行.后面单独谈论这种"覆盖索引"的优化

* 用于查询中的ORDER BY操作(按顺序查找):如果order by子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求

####B-Tree索引的限制(其实也能根据上面B-Tree结构图推理可知)
* 如果不是按照索引的最左列开始查找，则无法使用索引.例如查找名字(first_name)为Bill的人，也无法查找某个特定生日(dob)的人,
也无法查找姓(last_name)以某个字母结尾的人
* 不能跳过索引中的列.例如无法查询姓(last_name)为Smith并且在某个特定日期出生的人.索引部分使用,mysql只能使用索引的第一列
* 如果查询中有某个列的查询范围,则其右边所有列都无法索引查询.例如查询where last_name='Smith' and
first_name like 'J%' and dob='1976-12-23'，这个查询只能使用索引的前两列,因为like是一个范围条件

*索引的顺序是相当重要*

###哈希索引
TODO:cj to be done