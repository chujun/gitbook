
#5.1 索引基础
在mysql中，存储引擎使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行

##5.1.1索引类型
在mysql中,索引是在存储引擎层而不是服务器层实现的,所以没有统一的索引标准，不同存储引擎的索引类型也不一样

索引类型
###B-Tree索引
B-Tree数数据结构自行维基百科(通常意味着所有值都是顺序存储的，并且每一个叶子页到根的距离相同)

innodb用的就是B+Tree索引，后面还会详细介绍

*B-Tree结构大致逻辑结构*
![B-Tree结构上索引](img/five/B-Tree结构上索引图重要.png)

观察可知道和索引值相等的节点也在叶子页中

***[图重要系列]理解了这张图,B-Tree索引的逻辑结构，才能理解Mysql的最左匹配原则,多列匹配，范围匹配限制等索引规则,
其实都能根据这张图推理可知***

大致搜索算法步骤
1. 从索引根节点(上图未画出)开始进行搜索,
2. 根节点槽中存放了只想子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值(可能是多个列组成的值)和要查找的值
可以找到合适的指针进入下层子节点，这些指针实际上定义了当前节点的子节点页中值的上限和下限。
3. 最终存储引擎要么是找到对应的值，要么该记录不存在。

B-Tree对索引列是顺序组织存储的，所以适合查找范围数据

*下面是B-Tree结构之多列值索引,key(last_name,first_name,dob)[图重要系列]*
![B-Tree结构之多列值索引图重要](img/five/B-Tree结构之多列值索引图重要.png)

####B-Tree索引适合的查询类型(其实能根据上面B-Tree结构图推理可知)
```mysql
create table people(
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum('m','f') not null,
    key(last_name,first_name,dob)
);
```
* 全值匹配:和索引中的所有列进行匹配，例如查找姓名为Cuba Allen,出生于1960-01-01的人
* 匹配最左前缀:查找所有姓为Allen的人，即只使用索引的第一列
* 匹配列前缀:可以只匹配某一列的值的开头部分.例如查找所有以J开头的姓的人,只使用了索引的第一列
* 匹配范围值:例如查找姓在Allen和Barrymore之间的人.这里只使用了索引的第一列
* 精确匹配某一列并范围匹配另外一列:例如查找所有姓为Allen,并且名字是字母K开头的人。即第一列last_name全匹配，第二列first_name范围匹配
* 只访问索引的查询:即只需要访问索引，而无需访问数据行.后面单独谈论这种"覆盖索引"的优化

* 用于查询中的ORDER BY操作(按顺序查找):如果order by子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求

####B-Tree索引的限制(其实也能根据上面B-Tree结构图推理可知)
* 如果不是按照索引的最左列开始查找，则无法使用索引.例如查找名字(first_name)为Bill的人，也无法查找某个特定生日(dob)的人,
也无法查找姓(last_name)以某个字母结尾的人
* 不能跳过索引中的列.例如无法查询姓(last_name)为Smith并且在某个特定日期出生的人.索引部分使用,mysql只能使用索引的第一列
* 如果查询中有某个列的查询范围,则其右边所有列都无法索引查询.例如查询where last_name='Smith' and
first_name like 'J%' and dob='1976-12-23'，这个查询只能使用索引的前两列,因为like是一个范围条件

*索引的顺序是相当重要*

###哈希索引
基于哈希表实现,只有精确匹配索引所有列的查询才有效。
每一行数据，存储引擎都会针对索引所有列计算一个哈希码(hash code)。
哈希碰撞

缺点
* 哈希索引只包含哈希值和数据行指针，不存储字段值。所以必须读取行
* 哈希索引数据并不是顺序存储的，所以无法拥有排序
* 不支持部分索引列匹配查找。因为哈希索引是用索引所有列内容计算哈希值。例如(A,B)建立哈希索引，如果只查询数据列A，则无法使用该索引.
* 哈希索引只支持等值比较查询，包括=,in.不支持任何范围查询
* 访问哈希索引数据非常快，除非有很多哈希冲突
* 如果哈希冲突非常严重的话，索引维护操作也可能非常高。

特定使用场合
数据仓库应用中有一种经典的"星型"schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。

Innodb引擎有一种特别的功能叫"自适应哈希索引"(adaptive hash index),当Innodb注意到某些索引值被使用得非常频繁时，
它会在内存中基于B-Tree索引之上再创建一个哈希索引。(用户无法控制)
(这个不就是类似于应用系统中加上本地缓存HashMap嘛，一个道理，只不过取了个高大上的名字自适应哈希索引)

####创建自定义哈希索引
思路：在B-Tree索引基础上创建一个伪哈希索引。使用哈希值而不是索引值作为B-Tree进行索引列查找。需要在where子句中
手动使用哈希函数.

案例:字段存储url，并需要查询
```mysql
select * from website where url="https://www.mysql.com";
```
可以删除原来url列的索引，而新增一个索引列url_crc，使用crc32做哈希
```mysql
select * from website where url="https://www.mysql.com" and url_crc=CRC32("https://www.mysql.com");
```
这样会效率极高

缺陷:需要维护哈希值，可以手动维护，也可以使用触发器实现


###空间数据索引(R-Tree)
mysql对GIS支持并不完善,对GIS支持较完善的是PostgreSQL的PostGIS

###全文索引
搜索引擎

###其他索引类别
分形树索引(TukuDB,较新的一个数据结构,既有B-Tree的很多优点，也避免了B-Tree的一些缺点)


#5.2索引的优点

