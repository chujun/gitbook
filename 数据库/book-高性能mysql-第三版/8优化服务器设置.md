

## 如何创建一个好配置的最快方法
no 不是从学习配置项开始
no 从问哪个配置项应该怎么设置或者怎么修改开始
no 从检查服务器行为和询问那个配置项可以提升性能开始
yes 从理解mysql内核和行为开始
    --->利用这些知识指导配置mysql
    --->将想要的配置和当前配置进行比较，然后纠正重要并且有价值的不同之处

保证基本配置正确
特殊的配置项不应该成为服务器基本配置文件的一部分，只有当发现特定性能问题才应该设置它们

另一个节省时间和避免麻烦的好办法是使用默认配置，除非明确知道默认值会有问题。默认配置是经过最多实际测试的。

# 8.1MySQL配置的工作原理
mysql的配置机制

问题：mysql从哪里获得配置信息？
命令行参数和配置文件

配置文件格式
```
# Default Homebrew MySQL server config
[mysqld]
# Only allow connections from localhost
secure_file_priv=''
bind-address = 127.0.0.1

# Slow Query Log
slow_query_log                 = ON
slow_query_log_file            = /Users/chujun/logs/mysql/data/slow.log   # Adjust AppArmor configuration: /etc/apparmor.d/local/usr.sbin.mysqld
log_queries_not_using_indexes  = 0                                   # Interesting on developer systems!
long_query_time                = 0.1		# unit:second
# min_examined_row_limit         = 100
```

服务器通常读取mysqld这一段，许多客户端会读取client部分

## 8.1.1语法，作用域和动态性
配置项设置都是用小写，单词质检用下划线或者横线隔开
```
usr/sbin/mysqld --auto-increment-offset=5
usr/sbin/mysqld --auto_increment_offset=5
```

作用域
* 服务器级别(全局)
* 会话级别(针对连接)


运行时动态配置变量
```mysql
set SORT_BUFFER_SIZE =1;
set GLOBAL SORT_BUFFER_SIZE =1;
set @@sort_buffer_size:=1;
set @@SESSION .sort_buffer_size:=1;
set @@GLOBAL .SORT_BUFFER_SIZE :=1
```
mysql关闭时可能丢失这些配置

## 8.1.2设置变量的副作用
常见变量

* key_buffer_size
* table_cache_size
* thread_cache_size
* query_cache_size
* read_buffer_size
* read_rnd_buffer_size
* sor_buffer_size

如果查询必须使用一个更大的排序缓存才能比较好的执行，可以先在查询执行前增加sort_buffer_size的会话级别的值，执行完后恢复为default。
```mysql
set @@SESSION.SORT_BUFFER_SIZE :=1;
##Execute the query...
set @@SESSION.SORT_BUFFER_SIZE :=DEFAULT;
```
```mysql
set @saved_sort_buffer_size:=@@SESSION.sort_buffer_size;
set @@SESSION.sort_buffer_size:=1;
##execute the query
set @@session.sort_buffer_size:=@saved_sort_buffer_size;
```

## 8.1.3入门
设置变量值时需要注意的是值并不是越大越好，如果设置的值太高，可能更容易导致问题：可能会由于内存不足导致服务器内存交换，或者超过地址空间。

## 8.1.4通过基准测试迭代优化
一个认知:通常不建议通过建立一套基准测试方案，然后不断迭代验证配置项的修改来找到最佳配置方案


# 8.2什么不该做

* 放弃基于命中率的优化

# 8.3创建mysql配置文件
首先没有万能的适合所有场景的"最佳配置文件"

本书中的基础配置文件
```
[mysqld]
#general
datadir =/var/lib/mysql
socket  =/var/lib/mysql/mysql.sock
pid_file=/var/lib/mysql/mysql.pid
user = mysql
port=3305
default_storage_engine=innodb
#innodb
innodb_buffer_pool_size=<value>
innodb_log_file_size=<value>
innodb_file_per_table=1
innodb_flush_method=0_DIRECT
#myisam
key_buffer_size=<value>
#logging
log_error=/var/lib/mysql/mysql-error.log
slow_query_log=/var/lib/mysql/mysql-slow.log
#other
tmp_table_size=32M
max_heap_table_size=32M
query_cache_type=0
query_cache_size=0
max_connections=<value>
thread_cache=<value>
table_cache=<value>
#打开的操作系统文件句柄数量
open_files_limit=65535
[client]
socket=/var/lib/mysql/mysql.sock
port=3306
```

配置文件的第一件事是设置数据的位置

设置innodb缓存池大小的参考
![8innodb缓存池大小分配参考](img/eight/8innodb缓存池大小分配参考.png)

案例
![8innodb缓存池大小分配案例](img/eight/8innodb缓存池大小分配案例.png)

## 8.3.1检查mysql服务器状态变量

```shell
#每个60秒查看状态变量的增量变化(-r参数)
mysqladmin extended-status -ri60 -uroot -proot
mysqladmin -help
```

# 8.4配置内存使用
mysql内存消耗分为两类
* 可以控制的内存
* 不可控制的内存

配置内存步骤
1.确定可以使用的内存上限
2.确定每个连接mysql需要使用多少内存，例如排序缓存和临时表
3.确定操作系统需要多少内存才够用。包括同一台机器上其他程序使用的内存，如定时任务
4.把剩下的内存全部给mysql的缓存，例如innodb的缓冲池

## 8.4.1mysql可以使用多少内存
例如通常32位linux内核通常限制任意进程可以使用的内存量在2.5-2.7GB范围内，运行时地址空间溢出是非常危险的，不过现在基本都是64位操作系统了

## 8.4.2每个连接需要的内存
TODO:cj to be done

## 8.4.3为操作系统保留内存

## 8.4.4为缓存分配内存

## 8.4.5innodb缓冲池(buffer pool)

## 8.4.6myisam键缓存(key caches)
## 8.4.7线程缓存
## 8.4.8表缓存(table cache)
## 8.4.9innodb数据字典(data dictionary)

# 8.5配置mysql的i/o行为
## 8.5.1innodb i/o配置
详见专门介绍innodb引擎的本书籍吧<<mysql技术内幕-innodb存储引擎>>
## 8.5.2myisam的i/o配置

# 8.6配置mysql并发
## 8.6.1innodb并发配置
## 8.6.2myisam并发配置

# 8.7基于工作负载的配置
## 8.7.1优化blob和text的场景
## 8.7.2优化排序(filesorts)

# 8.8完成基本配置

# 8.9安全和稳定的设置

# 8.10高级innodb设置

# 8.11总结




# 资料